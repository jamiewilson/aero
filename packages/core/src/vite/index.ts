/**
 * Aero Vite plugin: HTML transform, virtual modules, dev server middleware, and static build.
 *
 * @remarks
 * Split into focused sub-plugins: config, virtuals (resolve/load), transform, SSR middleware.
 * Static build plugin runs after closeBundle; Nitro and image optimizer are composed in the factory.
 */

import type {
	AeroMiddlewareResult,
	AeroOptions,
	AliasResult,
	AeroRenderInput,
	ScriptEntry,
} from '../types'
import { extractObjectKeys } from '../utils/parse'
import type { Plugin, PluginOption, ResolvedConfig } from 'vite'
import { ViteImageOptimizer } from 'vite-plugin-image-optimizer'
import { nitro } from 'nitro/vite'

import {
	AERO_EMPTY_INLINE_CSS_PREFIX,
	AERO_HTML_VIRTUAL_PREFIX,
	CLIENT_SCRIPT_PREFIX,
	DEFAULT_API_PREFIX,
	getClientScriptVirtualUrl,
	RESOLVED_RUNTIME_INSTANCE_MODULE_ID,
	resolveDirs,
	RUNTIME_INSTANCE_MODULE_ID,
} from './defaults'

import { parse } from '../compiler/parser'
import { compile } from '../compiler/codegen'
import { resolvePageName } from '../utils/routing'
import { loadTsconfigAliases } from '../utils/aliases'
import { toPosixRelative } from '../utils/path'
import {
	createBuildConfig,
	discoverClientScriptContentMap,
	renderStaticPages,
	registerClientScriptsToMap,
	addDoctype,
} from './build'
import { spawn } from 'node:child_process'
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs'
import { createRequire } from 'node:module'
import { fileURLToPath } from 'node:url'
import path from 'path'

const require = createRequire(import.meta.url)

import { redirectsToRouteRules } from '../utils/redirects'

/** Shared state used by the Aero sub-plugins (config, virtuals, transform, ssr, hmr). */
interface AeroPluginState {
	config: ResolvedConfig | null
	aliasResult: AliasResult | null
	clientScripts: Map<string, ScriptEntry>
	runtimeInstancePath: string
	dirs: ReturnType<typeof resolveDirs>
	apiPrefix: string
	options: AeroOptions
}

const AERO_DIR = '.aero'
const NITRO_CONFIG_FILENAME = 'nitro.config.mjs'

/**
 * Generate Nitro config from Aero options and write to <projectRoot>/.aero/nitro.config.mjs.
 * root is the app/site directory (Vite config.root), e.g. kitchen-sink or a create-aero project folder.
 * Returns the absolute path to .aero (Nitro cwd so it loads this file).
 */
function writeGeneratedNitroConfig(
	root: string,
	serverDir: string,
	redirects: AeroOptions['redirects'],
): string {
	const aeroDir = path.join(root, AERO_DIR)
	mkdirSync(aeroDir, { recursive: true })
	const routeRules = redirectsToRouteRules(redirects ?? [])
	// Run Nitro with cwd=.aero; rootDir points to project root. Output dir must be absolute so .output lands in project root.
	// scanDirs must be absolute so Nitro finds server/ when cwd is .aero (relative 'server' would resolve to .aero/server and miss routes).
	// noPublicDir: true so Nitro does not serve from .output/public; server/routes/[...].ts catch-all serves static from dist at runtime.
	const nitroConfig = {
		rootDir: '..',
		output: { dir: path.join(root, '.output') },
		scanDirs: [path.join(root, serverDir)],
		routeRules,
		noPublicDir: true,
	}
	const content = `// Generated by Aero — do not edit
export default ${JSON.stringify(nitroConfig, null, 2)}
`
	writeFileSync(path.join(aeroDir, NITRO_CONFIG_FILENAME), content)
	return aeroDir
}

/** Run `nitro build` with generated config; used after static pages are written when options.nitro is true. */
async function runNitroBuild(_root: string, configCwd: string): Promise<void> {
	const nitroBin = process.platform === 'win32' ? 'nitro.cmd' : 'nitro'
	await new Promise<void>((resolve, reject) => {
		const child = spawn(nitroBin, ['build'], {
			cwd: configCwd,
			stdio: 'inherit',
			env: process.env,
		})

		child.on('error', reject)
		child.on('exit', code => {
			if (code === 0) {
				resolve()
				return
			}
			reject(new Error(`[aero] nitro build failed with exit code ${code ?? 'null'}`))
		})
	})
}

function createAeroConfigPlugin(state: AeroPluginState): Plugin {
	return {
		name: 'vite-plugin-aero-config',
		enforce: 'pre',
		config(userConfig, env) {
			const root = userConfig.root || process.cwd()
			state.aliasResult = loadTsconfigAliases(root)
			const site = state.options.site ?? ''

			// Production build: use minimal client entry (no instance/template chunks) so dist/assets stays small.
			const alias =
				env?.command === 'build'
					? [
							...state.aliasResult.aliases,
							{
								find: '@aero-ssg/core',
								replacement: require.resolve('@aero-ssg/core/entry-prod'),
							},
						]
					: state.aliasResult.aliases

			return {
				base: './',
				resolve: { alias },
				define: {
					'import.meta.env.SITE': JSON.stringify(site),
				},
				build: createBuildConfig(
					{ resolvePath: state.aliasResult.resolvePath, dirs: state.options.dirs },
					root,
				),
			}
		},
		configResolved(resolvedConfig) {
			state.config = resolvedConfig
		},
	}
}

/** True if filePath is an Aero template under client/pages, client/components, or client/layouts. */
function isAeroTemplateHtml(
	filePath: string,
	root: string,
	dirs: AeroPluginState['dirs'],
): boolean {
	const clientBase = path.join(root, dirs.client)
	const rel = path.relative(clientBase, filePath)
	if (rel.startsWith('..') || path.isAbsolute(rel)) return false
	const sep = path.sep
	return (
		rel.startsWith('pages' + sep) ||
		rel.startsWith('components' + sep) ||
		rel.startsWith('layouts' + sep)
	)
}

function createAeroVirtualsPlugin(state: AeroPluginState): Plugin {
	return {
		name: 'vite-plugin-aero-virtuals',
		enforce: 'pre',
		buildStart() {
			if (!state.config) return
			const contentMap = discoverClientScriptContentMap(state.config.root, state.dirs.client)
			contentMap.forEach((entry, url) => state.clientScripts.set(url, entry))
		},
		async resolveId(id, importer) {
			if (id === RUNTIME_INSTANCE_MODULE_ID) {
				return RESOLVED_RUNTIME_INSTANCE_MODULE_ID
			}

			if (id.startsWith(CLIENT_SCRIPT_PREFIX)) {
				return '\0' + id
			}
			if (id.startsWith('\0' + CLIENT_SCRIPT_PREFIX)) {
				return id
			}

			if (id.startsWith(AERO_HTML_VIRTUAL_PREFIX)) {
				return id
			}

			// Vite 8 may request .html with ?html-proxy&inline-css to extract inline styles; Aero .html are compiled to JS, so serve empty CSS.
			if (id.includes('html-proxy') && id.includes('inline-css')) {
				return AERO_EMPTY_INLINE_CSS_PREFIX + id
			}

			if (id.startsWith('aero:content')) {
				return null
			}

			const resolved = await this.resolve(id, importer, { skipSelf: true })
			if (resolved && resolved.id.endsWith('.html')) {
				// Only in build: resolve Aero template .html to virtual id so vite:build-html never sees them.
				// In dev we keep the real path so Vite's file watcher invalidates the module when the file changes (HMR + fresh SSR).
				if (
					state.config?.command === 'build' &&
					state.aliasResult &&
					isAeroTemplateHtml(resolved.id, state.config.root, state.dirs)
				) {
					return AERO_HTML_VIRTUAL_PREFIX + resolved.id.replace(/\.html$/i, '.aero')
				}
				return resolved
			}

			// Only try id + '.html' for path-like specifiers (relative, absolute, or path aliases like @components/foo).
			// Skip bare packages (nitro, nitro/app) and scoped packages (@aero-ssg/content/render).
			const isPathLike =
				id.startsWith('./') ||
				id.startsWith('../') ||
				id.startsWith('/') ||
				(id.startsWith('@') && !id.slice(1).split('/')[0].includes('-'))
			if (isPathLike && !id.includes('.') && !id.startsWith('\0')) {
				const resolvedHtml = await this.resolve(id + '.html', importer, { skipSelf: true })
				if (resolvedHtml) {
					if (
						state.config?.command === 'build' &&
						state.aliasResult &&
						isAeroTemplateHtml(resolvedHtml.id, state.config.root, state.dirs)
					) {
						return AERO_HTML_VIRTUAL_PREFIX + resolvedHtml.id.replace(/\.html$/i, '.aero')
					}
					return resolvedHtml
				}
			}

			return null
		},
		load(id) {
			if (id === RESOLVED_RUNTIME_INSTANCE_MODULE_ID) {
				return `export { aero, onUpdate } from ${JSON.stringify(state.runtimeInstancePath)}`
			}

			if (id.startsWith(AERO_EMPTY_INLINE_CSS_PREFIX)) {
				return '/* aero: no inline styles */'
			}

			if (id.startsWith(AERO_HTML_VIRTUAL_PREFIX)) {
				const filePath = id.slice(AERO_HTML_VIRTUAL_PREFIX.length).replace(/\.aero$/i, '.html')
				if (!state.config || !state.aliasResult) return null
				// So Vite invalidates this virtual module when the source .html changes (HMR).
				this.addWatchFile(filePath)
				try {
					const code = readFileSync(filePath, 'utf-8')
					const parsed = parse(code)
					const relativePath = toPosixRelative(filePath, state.config.root)
					const baseName = relativePath.replace(/\.html$/i, '')
					registerClientScriptsToMap(parsed, baseName, state.clientScripts)
					for (let i = 0; i < parsed.clientScripts.length; i++) {
						parsed.clientScripts[i].content = getClientScriptVirtualUrl(
							baseName,
							i,
							parsed.clientScripts.length,
						)
					}
					const generated = compile(parsed, {
						root: state.config.root,
						clientScripts: parsed.clientScripts,
						blockingScripts: parsed.blockingScripts,
						inlineScripts: parsed.inlineScripts,
						resolvePath: state.aliasResult.resolvePath,
					})
					return { code: generated, map: null }
				} catch {
					return null
				}
			}

			if (id.startsWith('\0' + CLIENT_SCRIPT_PREFIX)) {
				const virtualId = id.slice(1)
				const entry = state.clientScripts.get(virtualId)
				if (!entry) return ''

				if (entry.passDataExpr) {
					const keys = extractObjectKeys(entry.passDataExpr)
					if (keys.length > 0) {
						const preamble = `var __aero_data=(typeof window!=='undefined'&&window.__aero_data_next!==undefined)?window.__aero_data_next:{};if(typeof window!=='undefined')delete window.__aero_data_next;const { ${keys.join(', ')} } = __aero_data;\n`
						return preamble + entry.content
					}
				}

				return entry.content
			}
			return null
		},
	}
}

function createAeroTransformPlugin(state: AeroPluginState): Plugin {
	return {
		name: 'vite-plugin-aero-transform',
		enforce: 'pre',
		transform(code, id) {
			if (id.startsWith(AERO_HTML_VIRTUAL_PREFIX)) return null
			if (!id.endsWith('.html')) return null
			if (!state.config || !state.aliasResult) return null

			try {
				const parsed = parse(code)

				if (parsed.clientScripts.length > 0) {
					const relativePath = toPosixRelative(id, state.config.root)
					const baseName = relativePath.replace(/\.html$/i, '')
					registerClientScriptsToMap(parsed, baseName, state.clientScripts)
					for (let i = 0; i < parsed.clientScripts.length; i++) {
						parsed.clientScripts[i].content = getClientScriptVirtualUrl(
							baseName,
							i,
							parsed.clientScripts.length,
						)
					}
				}

				const generated = compile(parsed, {
					root: state.config.root,
					clientScripts: parsed.clientScripts,
					blockingScripts: parsed.blockingScripts,
					inlineScripts: parsed.inlineScripts,
					resolvePath: state.aliasResult.resolvePath,
				})

				return {
					code: generated,
					map: null,
				}
			} catch (err: any) {
				const relativePath = path.relative(state.config.root, id)
				this.error(`[aero] Error compiling ${relativePath}: ${err.message}`)
			}
		},
	}
}

function createAeroSsrPlugin(state: AeroPluginState): Plugin {
	return {
		name: 'vite-plugin-aero-ssr',
		configureServer(server) {
			server.middlewares.use(async (req, res, next) => {
				if (!req.url) return next()
				if (req.method && req.method.toUpperCase() !== 'GET') return next()

				const acceptsHtml = req.headers.accept?.includes('text/html')
				if (!acceptsHtml) return next()

				const pathname = req.url.split('?')[0] || '/'
				if (
					pathname.startsWith(state.apiPrefix) ||
					pathname.startsWith('/@fs') ||
					pathname.startsWith('/@id')
				) {
					return next()
				}

				const ext = path.extname(pathname)
				if (ext && ext !== '.html') return next()

				// Apply config redirects first (exact path match)
				const redirects = state.options.redirects
				if (redirects?.length) {
					for (const rule of redirects) {
						if (pathname === rule.from) {
							res.statusCode = rule.status ?? 302
							res.setHeader('Location', rule.to)
							res.end()
							return
						}
					}
				}

				try {
					const pageName = resolvePageName(req.url)
					const mod = await server.ssrLoadModule(RUNTIME_INSTANCE_MODULE_ID)

					const requestUrl = new URL(req.url, 'http://localhost')
					const requestHeaders = new Headers()
					for (const [name, value] of Object.entries(req.headers)) {
						if (value === undefined) continue
						if (Array.isArray(value)) {
							for (const item of value) requestHeaders.append(name, item)
							continue
						}
						requestHeaders.set(name, value)
					}

					const request = new Request(requestUrl.toString(), {
						method: req.method || 'GET',
						headers: requestHeaders,
					})

					let renderPageName = pageName
					let renderInput: AeroRenderInput = {
						url: requestUrl,
						request,
						routePath: pathname,
						site: state.options.site,
					}

					// Run middleware (redirects, rewrites, custom response)
					const middleware = state.options.middleware
					if (middleware?.length) {
						const ctx = {
							url: requestUrl,
							request,
							routePath: pathname,
							pageName,
							site: state.options.site,
						}
						for (const handler of middleware) {
							const result: AeroMiddlewareResult = await Promise.resolve(handler(ctx))
							if (result && 'redirect' in result) {
								res.statusCode = result.redirect.status ?? 302
								res.setHeader('Location', result.redirect.url)
								res.end()
								return
							}
							if (result && 'response' in result) {
								res.statusCode = result.response.status
								result.response.headers.forEach((v: string, k: string) => res.setHeader(k, v))
								const body = await result.response.arrayBuffer()
								res.end(Buffer.from(body))
								return
							}
							if (result && 'rewrite' in result) {
								if (result.rewrite.pageName !== undefined)
									renderPageName = result.rewrite.pageName
								const { pageName: _pn, ...rest } = result.rewrite
								renderInput = { ...renderInput, ...rest }
							}
						}
					}

					let rendered = await mod.aero.render(renderPageName, renderInput)

					if (rendered === null) {
						res.statusCode = 404
						rendered = await mod.aero.render('404', renderInput)
					}

					if (rendered === null) {
						res.statusCode = 404
						res.setHeader('Content-Type', 'text/html; charset=utf-8')
						res.end('<h1>404 — Not Found</h1>')
						return
					}

					rendered = addDoctype(rendered)

					const transformed = await server.transformIndexHtml(req.url, rendered)
					res.setHeader('Content-Type', 'text/html; charset=utf-8')
					res.end(transformed)
				} catch (err) {
					next(err)
				}
			})
		},
	}
}

/**
 * Aero Vite plugin factory. Returns an array of plugins: config, virtuals, transform, SSR,
 * static-build, image optimizer, and optionally Nitro (serve only).
 * HMR for templates and content is handled by Vite's dependency graph when the app uses a single
 * client entry that imports @aero-ssg/core and calls aero.mount().
 *
 * @param options - AeroOptions (nitro, apiPrefix, dirs). Nitro can be disabled at runtime via AERO_NITRO=false.
 * @returns PluginOption[] to pass to Vite's plugins array.
 */
export function aero(options: AeroOptions = {}): PluginOption[] {
	const dirs = resolveDirs(options.dirs)
	const apiPrefix = options.apiPrefix || DEFAULT_API_PREFIX
	const enableNitro = options.nitro === true && process.env.AERO_NITRO !== 'false'

	const runtimeInstanceJsPath = fileURLToPath(
		new URL('../runtime/instance.js', import.meta.url),
	)
	const runtimeInstanceTsPath = fileURLToPath(
		new URL('../runtime/instance.ts', import.meta.url),
	)
	const runtimeInstancePath = existsSync(runtimeInstanceJsPath)
		? runtimeInstanceJsPath
		: runtimeInstanceTsPath

	const state: AeroPluginState = {
		config: null,
		aliasResult: null,
		clientScripts: new Map<string, ScriptEntry>(),
		runtimeInstancePath,
		dirs,
		apiPrefix,
		options,
	}

	const aeroConfigPlugin = createAeroConfigPlugin(state)
	const aeroVirtualsPlugin = createAeroVirtualsPlugin(state)
	const aeroTransformPlugin = createAeroTransformPlugin(state)
	const aeroSsrPlugin = createAeroSsrPlugin(state)

	/** Plugins needed for static build (resolve, load, transform); no SSR/HMR. */
	const aeroCorePlugins: Plugin[] = [aeroConfigPlugin, aeroVirtualsPlugin, aeroTransformPlugin]

	const staticBuildPlugin: Plugin = {
		name: 'vite-plugin-aero-static',
		apply: 'build',
		async closeBundle() {
			// Project root (site/app directory: e.g. kitchen-sink or create-aero generated project), not monorepo root
			const root = state.config!.root
			const outDir = state.config!.build.outDir
			const shouldMinifyHtml =
				state.config!.build.minify !== false &&
				typeof import.meta !== 'undefined' &&
				import.meta.env?.PROD
			const staticPlugins = options.staticServerPlugins?.length
				? [...aeroCorePlugins, ...options.staticServerPlugins]
				: aeroCorePlugins
			await renderStaticPages(
				{
					root,
					resolvePath: state.aliasResult!.resolvePath,
					dirs: options.dirs,
					apiPrefix,
					vitePlugins: staticPlugins,
					minify: shouldMinifyHtml,
					site: options.site,
					redirects: options.redirects,
				},
				outDir,
			)
			if (enableNitro) {
				const configCwd = writeGeneratedNitroConfig(root, dirs.server, options.redirects)
				await runNitroBuild(root, configCwd)
			}
		},
	}

	const plugins: PluginOption[] = [
		aeroConfigPlugin,
		aeroVirtualsPlugin,
		aeroTransformPlugin,
		aeroSsrPlugin,
		staticBuildPlugin,
		ViteImageOptimizer({
			exclude: undefined,
			include: undefined,
			includePublic: true,
			logStats: true,
			ansiColors: true,
			svg: {
				multipass: true,
				plugins: [
					{
						name: 'preset-default',
						params: {
							overrides: {
								cleanupNumericValues: false,
							},
							cleanupIDs: {
								minify: false,
								remove: false,
							},
							convertPathData: false,
						},
					},
				],
			},
			png: { quality: 80 },
			jpeg: { quality: 80 },
			jpg: { quality: 80 },
			tiff: { quality: 80 },
			gif: {},
			webp: { lossless: true },
			avif: { lossless: true },
		}),
	]

	if (enableNitro) {
		const rawNitroPlugins = nitro({ serverDir: dirs.server })
		const nitroPlugins = Array.isArray(rawNitroPlugins) ? rawNitroPlugins : [rawNitroPlugins]
		for (const nitroPlugin of nitroPlugins) {
			if (!nitroPlugin || typeof nitroPlugin !== 'object') continue
			const originalApply = nitroPlugin.apply
			plugins.push({
				...nitroPlugin,
				apply(pluginConfig, env) {
					if (env.command !== 'serve') return false
					if ((env as { isPreview?: boolean }).isPreview) return false
					if (typeof originalApply === 'function') {
						return originalApply(pluginConfig, env)
					}
					if (originalApply) return originalApply === 'serve'
					return true
				},
			})
		}
	}

	return plugins
}
